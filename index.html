<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Thành phố nhỏ - Babylon.js</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <style> html, body { margin: 0; height: 100%; } canvas { width: 100%; height: 100%; } </style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

const createScene = () => {
  const scene = new BABYLON.Scene(engine);
  const camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2.2, Math.PI / 3, 100, new BABYLON.Vector3(0, 0, 0), scene);
  camera.attachControl(canvas, true);
  const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0), scene);

  // Vật liệu
  const roadMat = new BABYLON.StandardMaterial("roadMat", scene);
  roadMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);

  const grassMat = new BABYLON.StandardMaterial("grassMat", scene);
  grassMat.diffuseColor = new BABYLON.Color3(0.2, 0.6, 0.2);

  const buildingMats = ["#C45", "#49C", "#FC6", "#6CF"].map(color => {
    let mat = new BABYLON.StandardMaterial("mat", scene);
    mat.diffuseColor = BABYLON.Color3.FromHexString(color);
    return mat;
  });

  // Hàm tạo block: nhà hoặc công viên
  function createBlock(x, z, type) {
    if (type === "building") {
      const h = Math.random() * 10 + 5;
      const b = BABYLON.MeshBuilder.CreateBox("building", { width: 16, depth: 16, height: h }, scene);
      b.position.set(x, h / 2, z);
      b.material = buildingMats[Math.floor(Math.random() * buildingMats.length)];
      b.actionManager = new BABYLON.ActionManager(scene);
      b.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, () => {
        alert("Bạn đã click vào tòa nhà!");
      }));
    } else if (type === "park") {
      const ground = BABYLON.MeshBuilder.CreateGround("park", { width: 16, height: 16 }, scene);
      ground.position.set(x, 0, z);
      ground.material = grassMat;

      // Thêm vài cây đơn giản
      for (let i = 0; i < 5; i++) {
        const tx = x + Math.random() * 12 - 6;
        const tz = z + Math.random() * 12 - 6;

        const trunk = BABYLON.MeshBuilder.CreateCylinder("trunk", { height: 1, diameter: 0.5 }, scene);
        trunk.position.set(tx, 0.5, tz);
        const leaves = BABYLON.MeshBuilder.CreateSphere("leaves", { diameter: 2 }, scene);
        leaves.position.set(tx, 2, tz);
        let leafMat = new BABYLON.StandardMaterial("leafMat", scene);
        leafMat.diffuseColor = new BABYLON.Color3(0.1, 0.6, 0.3);
        leaves.material = leafMat;
      }
    }
  }

  // Hàm tạo đường
  function createRoad(x, z, width, depth) {
    const road = BABYLON.MeshBuilder.CreateBox("road", { width: width, height: 0.1, depth: depth }, scene);
    road.position.set(x, 0.05, z);
    road.material = roadMat;
  }

  // Tạo lưới 3x3 block thành phố
  const blockSize = 20;
  const roadWidth = 6;
  const total = 3;

  for (let i = 0; i < total; i++) {
    for (let j = 0; j < total; j++) {
      const x = (i - 1) * (blockSize + roadWidth);
      const z = (j - 1) * (blockSize + roadWidth);
      const type = Math.random() > 0.3 ? "building" : "park";
      createBlock(x, z, type);
    }
  }

  // Tạo đường ngang & dọc
  for (let i = -1; i <= 1; i++) {
    for (let j = -2; j <= 2; j++) {
      // Đường dọc
      createRoad(i * (blockSize + roadWidth), j * (blockSize / 2 + roadWidth), roadWidth, blockSize);
      // Đường ngang
      createRoad(j * (blockSize / 2 + roadWidth), i * (blockSize + roadWidth), blockSize, roadWidth);
    }
  }
BABYLON.SceneLoader.ImportMesh("", "models/", "restaurant.glb", scene, function (meshes) {
  const model = meshes[0];
  model.position = new BABYLON.Vector3(10, 0, 10);
  model.scaling = new BABYLON.Vector3(2, 2, 2); // Tùy chỉnh tỉ lệ
});
  // Mini-map camera
const miniCam = new BABYLON.FreeCamera("MiniCam", new BABYLON.Vector3(0, 100, 0), scene);
miniCam.setTarget(BABYLON.Vector3.Zero());
miniCam.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
miniCam.orthoLeft = -60;
miniCam.orthoRight = 60;
miniCam.orthoTop = 60;
miniCam.orthoBottom = -60;
miniCam.layerMask = 0x20000000;

// Render texture
const miniMapTexture = new BABYLON.RenderTargetTexture("minimap", 512, scene, false);
miniMapTexture.activeCamera = miniCam;
scene.customRenderTargets.push(miniMapTexture);

// Tạo viewport nhỏ
const plane = BABYLON.MeshBuilder.CreatePlane("minimapDisplay", {size: 0.3}, scene);
plane.scaling.set(200, 200, 1);
plane.position.set(80, 80, -200); // Đặt ra khỏi tầm nhìn chính
const miniMat = new BABYLON.StandardMaterial("miniMapMat", scene);
miniMat.diffuseTexture = miniMapTexture;
miniMat.emissiveColor = BABYLON.Color3.White();
plane.material = miniMat;
plane.isPickable = false;

// GUI layer hiển thị trong góc phải
const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
const image = new BABYLON.GUI.Image("miniMapImage", "");
image.source = miniMapTexture.renderList ? miniMapTexture.renderList[0] : null;
image.width = "200px";
image.height = "200px";
image.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
image.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
advancedTexture.addControl(image);

  return scene;
};

const scene = createScene();
engine.runRenderLoop(() => scene.render());
window.addEventListener("resize", () => engine.resize());
</script>
</body>
</html>
